# 信息
## 函数宏
- WIFEXITED(status) 若此值为非0 表明进程正常结束。
> 若上宏为真，此时可通过WEXITSTATUS(status)获取进程退出状态(exit时参数)
- WIFSIGNALED(status)为非0 表明进程异常终止。
> 若上宏为真，此时可通过WTERMSIG(status)获取使得进程退出的信号编号
- WIFSTOPPED(status)为非0 表明进程处于暂停状态
> 若上宏为真，此时可通过WSTOPSIG(status)获取使得进程暂停的信号编号
- WIFCONTINUED(status) 非0表示暂停后已经继续运行。

## sigprocmask函数;

- 首先看它的作用：

   一个进程的信号屏蔽字规定了当前阻塞而给该进程的信号集。调用函数sigprocmask可以检测或更改其信号屏蔽字，或者在一个步骤中同时执行这两个操作。
```c
#include <signal.h>
int sigprocmask( int how, const sigset_t *restrict set, sigset_t *restrict oset );
```
- 返回值：
  
  若成功则返回0，若出错则返回-1


参数说明


  	说明
	1. how
	SIG_BLOCK	  该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。set包含了我们希望阻塞的附加信号
	SIG_UNBLOCK	  该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集补集的交集。set包含了我希望解除阻塞的信号
	SIG_SETMASK	  该进程新的信号屏蔽字将被set指向的信号集的值代替
 
	2. oset是非空指针，那么进程的当前信号屏蔽字通过oset返回。

	其次，若set是一个非空指针，则参数how指示如何修改当前信号屏蔽字。

	表10-4说明了how可选用的值。注意，不能阻塞SIGKILL和SIGSTOP信号。

	表10-4 用sigprocmask更改当前信号屏蔽字的方法

	如果set是空指针，则不改变该进程的信号屏蔽字，how的值也无意义。


+ 在调用sigprocmask后如果有任何未决的、不再阻塞的信号，*则在sigprocmask返回前，至少会将其中一个信号递送给该进程。*

*尤其注意最后这句话！！！*

我们知道， 当造成信号的事件发生，比如硬件异常（如除以0），软件条件（如alarm计时器超时）、终端产生的信号或调用kill函数产生的信号，内核向进程发送一个信号。当我们连续多次产生同一个信号，比如SIGINT信号， 系统究竟是只接受第一个而屏蔽了以后多个信号呢？还是都接收信号？我们当且敢肯定的是第一个信号是会被接收（在sigprocmask中没有屏蔽这个信号）的。此时，调用进程会转到信号处理程序中， 因为我们可以用sigprocmask来检测当前进程的信号屏蔽字的，所以我们就可以在信号处理程序中来查看此信号是否被屏蔽了。
所以我们来看一段代码，代码意思就是检测SIGINT信号， 当发生信号后转到sig_int(int) 函数中， 在pr_mask函数中，使用了sigprocmask函数来检测当前进程是否屏蔽了SIGINT信号：

这里结果就出乎我的预料了。首先在没有按下ctrl+c产生SIGINT信号前， 进程中没有屏蔽SIGINT信号，而当我们产生中断信号是，由结果可以看到SIGINT信号被屏蔽了，但出人意料的是当我们多次产生中断信号的时候， 进程全部都接收了。  现在再读读

在调用sigprocmask后如果有任何未决的、不再阻塞的信号，则在sigprocmask返回前，至少会将其中一个信号递送给该进程。
也就是说，因为程序中我们并没有屏蔽中断信号，而当进程在处理中断信号的时候是屏蔽了接下来的中断信号，所以在信号处理函数中会有SIGINT出现， 而当信号处理函数完成，准确的说是sigprocmask完成前， 接下来的SIGINT都会被接收处理.

## dup()以及dup2()函数

### dup()
- int dup(int oldfd);
- oldfd: old file descriptor whose copy is to be created.
> dup()内核函数为文件的描述文件的拷贝
> 该函数使用最小的未使用值作为新的描述符
> 如果成功创建文件描述符的副本，则该原始描述符和副本可互换使用。
> 文件描述符和其副本均指向同一个打开的文件，因此他们共享文件偏移量和文件状态标志。
>> - tips:
>> > - 文件描述符在形式上是一个非负整数。实际，文件描述符是一个索引值，指向内核中为每个进程所维护的该进程打开的文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些设计底层的程序编写往往会围绕着文件描述符展开。
>> > - 文件描述符概念。Linux中，将一切都看作是文件，当进程打开现有文件或者创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符进行。
>> > - 文件描述符、文件、进程之间的关系
>> >> - 1. 描述
>> >> >> 每个文件描述符会与一个打开的文件相对应。
>> >> >> 不同的文件描述符也可能指向同一个文件
>> >> >> 相同的文件可以被不同的进程打开，也可以在同一个进程中被多次打开。
>> >> - 2. 系统为维护文件描述符，建立的三个表
>> >> >> 进程级的文件描述符表
>> >> >> 系统级的文件描述符表
>> >> >> 文件的i-node 表
>> >> >> > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inode 是一个重要概念，是理解Unix/Linux文件系统和硬盘存储的基础.理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象为一个简单概念，从而大大简化用户接口.文件存储在硬盘上，硬盘的最小存储单位是“扇区”（sector），每个扇区存储固定值（比如512字节）。  
>> >> >> > &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作系统读取硬盘的时候会一个个扇区的读取，这样效率很低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的块，是文件存取的最小单位，“块”的大小，常见是4KB，即连续八个sector组成要给block。文件数据都存储在块中，那么很显然，我们还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的代销、文件的最后修改日期等等，这种存储文件辕信息的区域就叫做inode，文中译名为“索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的信息。
### dup2()
> int dup2(int oldfd, int newfd);
> oldfd: old file descriptor
> newfd new file descriptor which is used by dup2() to create a copy.

> 注意事项
> - 在使用dup()以及dup2()函数时需要包含unistd.h系统函数。
> - 如果文件描述符预先打开了，该描述符就会静默关闭。
> - 如果旧的描述符不是一个可用的有效的文件，该调用会失败，并且新的文件描述符不会关闭。
> - 如果旧的文件描述符可用，并且新描述符与旧描述符相同，则dup2()不会做任何操作，然后返回新描述符的值。

